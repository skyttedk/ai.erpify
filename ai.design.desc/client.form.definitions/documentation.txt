Documentation
Overview
This configuration file defines how forms, lists, or lookup screens are rendered in your ERP application. It uses a declarative approach, allowing non-UI developers to define the entire UI (layout, data source, actions, and even dynamic behaviors) without hard-coding the UI logic.

Configuration Structure
id
A unique identifier for the configuration.

caption
An object containing:

key: The internationalization key.
default: The default caption (used if no translation is provided).
type
Specifies the form type. Supported values include "list", "form", "lookup", "search", etc.

dataSource
The backend model or table name (e.g., "customers") used to populate the form.

filter
Defines default filtering criteria. It supports a structured query format where each criterion includes:

field: Name of the field.
operator: Comparison operator (e.g., "equals", "notEquals").
value: The value to compare.
sort
Specifies the default sorting field and order for list views.

pagination
Configuration for list pagination, including page size and the current page number.

permissions
Overall permissions for the form:

allowInsert, allowDelete, allowModify: Boolean flags controlling record-level actions.
fields: An optional section to control field-level permissions (e.g., making a field read-only).
menu
Defines the menu structure:

Each menu group includes a caption (with i18n support) and an array of menu items.
Each menu item specifies its caption and the action (such as a function name or command) that is triggered.
layout
The core section for UI definition:

layoutType: Determines the responsive layout style (e.g., "grid" or "flex").
groups: An array of field groups. Each group has:
id: A unique group identifier.
caption: Internationalized caption for the group.
fields: An array of field definitions.
name: Unique field identifier.
caption: Internationalized display label.
type: Data type (e.g., "text", "number", "date", "email", "select").
required: Whether the field must be filled.
defaultValue: The pre-populated value.
maxLength / minLength / pattern: Validation properties.
readOnly / disabled: UI state controls.
options: For select fields, an array of value/label pairs.
events: Event handlers like onChange, onFocus, or onBlur (mapped to application functions).
localeFormat: Format string for locale-specific formatting (useful for dates or numbers).
conditional: Rules for conditionally showing or hiding the field based on other field values.
debug
A Boolean flag. When enabled, the parser and renderer can output detailed error messages or warnings to help during development.

customTemplates
Allows specifying custom templates (or hook names) for parts of the form (e.g., header and footer).

metadata
Contains meta-information such as version, author, and the last updated date for documentation and maintenance purposes.

Internationalization (i18n)
Use the provided key for each caption to reference external resource files.
The default value is used if no localized text is found.
Data Source Integration
The dataSource value links the form to your backend data.
Use the filter, sort, and pagination sections to control which records are fetched and how they are presented.
Permissions
Global permissions apply to overall form actions.
Field-level permissions let you mark certain fields as non-editable for specific roles.
Menu Configuration
Menu groups and items can trigger backend functions or client-side scripts.
They are configured with internationalized captions and an action identifier.
Layout and Field Definitions
Layout is defined using groups. Each group can be rendered as a responsive grid or flex container.
Fields include extended properties:
Validation: Use maxLength, minLength, and regex patterns.
Events: Map UI events to function names.
Conditional logic: Define rules to display or hide fields based on other field values.
Debug Mode and Custom Templates
Enable debug during development to see detailed messages.
customTemplates allow overriding default rendering for the header or footer.
Metadata
Update the metadata section to track versioning and authorship.
4. How to Use
Define Your Form:
Create a JSON configuration using the provided structure. Adjust properties such as the data source, layout groups, and field definitions as needed.

Internationalization:
Reference your i18n resource files using the caption keys. The UI rendering engine should replace keys with localized strings at runtime.

Parsing and Rendering:
Your application should include:

A Parser Component that validates the JSON against the provided schema.
A Renderer Component (using a framework like React, Angular, or Vue.js) that dynamically creates the UI based on the configuration.
Custom Behaviors:

Map the events (e.g., validateEmail, handleSubscriptionChange) to actual functions in your application.
Use conditional rules to dynamically show or hide fields.
Security Considerations:
Always sanitize user input and validate on the backend even if the form enforces field-level rules.

Debug and Extend:
Enable debug during development for detailed logging. Extend the configuration by adding custom field properties or plugins as your application grows.

Schema Validation:
Integrate the provided JSON Schema into your CI/CD process to catch configuration errors early.

By following this documentation and using the unified example, you can rapidly develop standardized, secure, and extensible forms for your ERP application.