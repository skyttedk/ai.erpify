import { WebSocketServer } from 'ws';
import { RateLimiterMemory } from 'rate-limiter-flexible';
import pool from './config/db.js';
import Models from './models/index.js';

// Initialize rate limiter: 100 requests per minute per IP
const rateLimiter = new RateLimiterMemory({ points: 100, duration: 60 });
const clients = new Set();

// Placeholder for token verification
async function verifyToken(token) {
    return true; // Replace with real logic
}

// Handle individual client connections
async function handleClientConnection(ws) {
    clients.add(ws);
    console.log('Client connected');

    ws.on('message', async (message) => {
        let client;
        try {
            // Apply rate limiting based on client IP
            await rateLimiter.consume(ws._socket.remoteAddress);

            // Parse incoming message
            const request = JSON.parse(message);

            // Verify token
            if (!request.token || !(await verifyToken(request.token))) {
                ws.send(JSON.stringify({ success: false, message: 'Unauthorized' }));
                return;
            }

            // Database transaction
            client = await pool.connect();
            await client.query('BEGIN');

            const { model, action, parameters = {}, requestId } = request;

            const ModelClass = Models[model];

            if (!ModelClass) {
                throw new Error(`Model "${model}" not found`);
            }
            if (typeof ModelClass[action] !== 'function') {
                throw new Error(`Action "${action}" not available for model "${model}"`);
            }

            // Convert parameters object to array based on action requirements
            const expectedParams = getFunctionParameters(ModelClass[action]);
            const paramCount = expectedParams.length;

            // Last parameter is 'client' which we append manually
            const expectedUserParams = paramCount > 0 && expectedParams[paramCount - 1] === 'client'
                ? paramCount - 1
                : paramCount;

            // Map parameters object to array based on expected parameter names
            let paramArray = [];
            if (expectedUserParams > 0) {
                // For actions expecting specific parameters, map them from the object
                const paramNames = expectedParams.slice(0, expectedUserParams);
                paramArray = paramNames.map(name => {
                    if (parameters[name] === undefined) {
                        throw new Error(`Missing required parameter: ${name}`);
                    }
                    return parameters[name];
                });
            } else if (Object.keys(parameters).length > 0) {
                // For actions that don't expect specific parameters but we got some,
                // pass the whole parameters object as a single argument
                paramArray = [parameters];
            }

            // Call the method with parameters spread as arguments, plus client
            const result = await ModelClass[action](...paramArray, client);

            await client.query('COMMIT');
            ws.send(JSON.stringify({
                success: true,
                message: 'Operation succeeded',
                requestId: request.requestId,
                result
            }));
        } catch (error) {
            if (client) await client.query('ROLLBACK');
            console.error('Error:', error);
            ws.send(JSON.stringify({ success: false, message: error.message }));
        } finally {
            if (client) client.release();
        }
    });

    ws.on('close', () => {
        clients.delete(ws);
        console.log('Client disconnected');
    });

    ws.on('error', (error) => console.error('WebSocket error:', error));
}

// Main function to start the server (unchanged)
async function main() {
    const { PORT = 8011 } = process.env;
    const wss = new WebSocketServer({ port: PORT });
    console.log(`WebSocket server running on ws://localhost:${PORT}`);

    wss.on('connection', handleClientConnection);
    wss.on('error', (error) => console.error('Server error:', error));
    pool.on('error', (error) => console.error('Pool error:', error));

    async function shutdown() {
        wss.close();
        await pool.end();
        console.log('Server shut down');
        process.exit(0);
    }
    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);

    process.on('unhandledRejection', (reason) => console.error('Unhandled Rejection:', reason));
    process.on('uncaughtException', (error) => console.error('Uncaught Exception:', error));
}

main().catch(console.error);

function getFunctionParameters(fn) {
    const fnStr = fn.toString();
    const paramStr = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'));
    if (!paramStr.trim()) return [];
    return paramStr.split(',').map(param => param.trim());
}

export { handleClientConnection, main };